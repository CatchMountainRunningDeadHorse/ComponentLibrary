# 一、拖拽窗口使用：webkit-app-region

```
在 Electron 中，当你为窗口设置无边框（frame: false）并使用 -webkit-app-region: drag; 样式来实现自定义标题栏的拖拽功能时，可能会发现双击自定义标题栏区域会触发窗口最大化的行为。这是因为 -webkit-app-region 属性使得该元素与系统级别的窗口管理器交互，它不仅使元素可以用于拖动窗口，而且可能还会响应系统对标题栏区域默认的双击事件。

在某些操作系统和版本的 Electron 中，即使窗口设置了无边框，但因为应用到了 -webkit-app-region 的样式，系统仍然识别到这个区域是类似于原生标题栏的可操作区域，并执行了相应的双击最大化操作。
```

# 二、在mac os上

```
就算设置没问题，也会出现：双击窗口，移动窗口的问题
```

```
const mainWindow = new BrowserWindow({
    width: 900,
    height: 670,
    show: false,
    frame:false, //无边框窗口
    maximizable: false, // 禁止最大化
    resizable: false, // 设置为 false 禁用调整窗口大小
    autoHideMenuBar: true,
    ...(process.platform === 'linux' ? { icon } : {}),
    webPreferences: {
      preload: join(__dirname, '../preload/index.js'),
      sandbox: false
    }
})
```

# 三、windows解决双击放大问题

```
//进入后台管理系统首页
  ipcMain.handle('resize-window',() => {
    //窗口大小
    mainWindow.setSize(1200, 720);

    //窗口居中
    mainWindow.center();
    //窗口大小可以修改
    mainWindow.setResizable(true);

	  // 设置窗口是否可以由用户手动最大化。
    mainWindow.setMenu(null);

    // 设置用户是否可以调节窗口尺寸
    mainWindow.setMaximizable(false);
    
    //窗口最小值
    mainWindow.setMinimumSize(1000, 500);

 })
```



# 四、最终解决办法

##### 4.1 拖拽窗口hooks

```
import { ref, onUnmounted } from 'vue';
import type { Ref } from 'vue';

export default function useWindowDrag(): {
  isKeyDown: Ref<boolean>;
  handleMouseDown: (event: MouseEvent) => void;
} {
  const isKeyDown = ref(false);
  const initialX = ref(0);
  const initialY = ref(0);

  const handleMouseDown = (event: MouseEvent): void => {
    isKeyDown.value = true;
    initialX.value = event.x;
    initialY.value = event.y;

    const onMouseMove = (ev: MouseEvent): void => {
      if (isKeyDown.value) {
        const x = ev.screenX - initialX.value;
        const y = ev.screenY - initialY.value;
        const data = {
          appX: x,
          appY: y,
        };
        window.electron.ipcRenderer.invoke('custom-adsorption', data);
      }
    };

    document.addEventListener('mousemove', onMouseMove);

    const onMouseUp = (): void => {
      isKeyDown.value = false;
      document.removeEventListener('mousemove', onMouseMove as EventListener);
    };

    document.addEventListener('mouseup', onMouseUp);

    // 清理事件监听器
    onUnmounted(() => {
      document.removeEventListener('mousemove', onMouseMove as EventListener);
      document.removeEventListener('mouseup', onMouseUp as EventListener);
    });
  };

  return {
    isKeyDown,
    handleMouseDown,
  };
}
```

